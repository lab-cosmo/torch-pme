"""
Fourier Convolution
===================
"""
import torch

class FourierSpaceConvolution:
    """
    Class for handling all the steps necessary to compute the convolution f*G between
    two functions f and G, where the values of f are provided on a discrete mesh.

    :param cell: torch.tensor of shape (3,3) Tensor specifying the real space unit
        cell of a structure, where cell[i] is the i-th basis vector
    """
    def __init__(self, cell: torch.tensor):
        self.cell = cell

    def generate_kvectors(self, ns: torch.tensor) -> torch.tensor:
        """
        For a given unit cell, compute all reciprocal space vectors that are used to
        perform sums in the Fourier transformed space.
        
        :param cell: torch.tensor of shape (3,3)
            Tensor specifying the real space unit cell of a structure, where cell[i] is
            the i-th basis vector
        :param ns: torch.tensor of shape (3,)
            ns = [nx, ny, nz] contains the number of mesh points in the x-, y- and
            z-direction, respectively. For faster performance during the Fast Fourier
            Transform (FFT) it is recommended to use values of nx, ny and nz that are
            powers of 2.
    
        :returns: torch.tensor of shape [N_k,3] Contains all reciprocal space vectors
            that will be used during Ewald summation (or related approaches). The number
            N_k of such vectors is given by N_k = nx * ny * nz. k_vectors[i] contains
            the i-th vector, where the order has no special significance.
        """
        # Define basis vectors of the reciprocal cell
        reciprocal_cell = 2*torch.pi*self.cell.inverse().T
        bx = reciprocal_cell[0]
        by = reciprocal_cell[1]
        bz = reciprocal_cell[2]
    
        # Generate all reciprocal space vectors
        nxs_1d = torch.fft.fftfreq(ns[0]) * ns[0]
        nys_1d = torch.fft.fftfreq(ns[1]) * ns[1]
        nzs_1d = torch.fft.rfftfreq(ns[2]) * ns[2] # real FFT
        nxs, nys, nzs = torch.meshgrid(nxs_1d, nys_1d, nzs_1d, indexing='ij')
        nxs = nxs.reshape((ns[0],ns[1],len(nzs_1d),1))
        nys = nys.reshape((ns[0],ns[1],len(nzs_1d),1))
        nzs = nzs.reshape((ns[0],ns[1],len(nzs_1d),1))
        k_vectors = nxs * bx + nys * by + nzs * bz
    
        return k_vectors

    def compute(self, mesh_values: torch.tensor, kernel_func, value_at_origin=None) -> torch.tensor:
        """
        Compute the "electrostatic potential" from the density defined
        on a discrete mesh.

        :param mesh_values: torch.tensor of shape (n_channels, nx, ny, nz)
            The values of the density defined on a mesh.
        :param kernel_func: function
            The kernel function takes k**2 as an argument and should output the Fourier
            transform of the potential. For the standard Ewald summation using the
            Coulomb potential of a Gaussian charge density:
            :math:`G(k) = 4pi / k**2 * exp(-0.5*(sigma*k)**2)` and hence
            :math:`kernel_func(x) = 4pi / x * exp(-0.5*sigma**2 * x)` since x=k**2.
        :param value_at_origin: float
            For some kernel functions like the one above, the value
            at k=0 is singular. In such cases, it is possible to
            manually specify what G(0) should be set to.

        :returns: torch.tensor of shape (n_channels, nx, ny, nz)
            The potential evaluated on the same mesh points as the provided
            density.
        """
        # Get shape information from mesh
        n_channels, nx, ny, nz = mesh_values.shape
        ns = torch.tensor([nx, ny, nz])
        
        # Get the relevant reciprocal space vectors (k-vectors)
        # and compute their norm.
        kvectors = self.generate_kvectors(ns)
        knorm_sq = torch.sum(kvectors**2, axis=3)
    
        # G(k) is the Fourier transform of the Coulomb potential
        # generated by a Gaussian charge density
        # We remove the singularity at k=0 by explicitly setting its
        # value to be equal to zero. This mathematically corresponds
        # to the requirement that the net charge of the cell is zero.
        G = kernel_func(knorm_sq)
        if value_at_origin is not None:
            G[0,0,0] = value_at_origin
    
        # Fourier transforms consisting of the following substeps:
        # 1. Fourier transform the density
        # 2. multiply by kernel in k-space
        # 3. transform back
        # For the Fourier transforms, we use the normalization conditions
        # that do not introduce any extra factors of 1/n_mesh.
        # This is why the forward transform (fft) is called with the
        # normalization option 'backward' (the convention in which 1/n_mesh
        # is in the backward transformation) and vice versa for the 
        # inverse transform (irfft).
        volume = self.cell.det()
        dims = (1,2,3) # dimensions along which to Fourier transform
        mesh_hat = torch.fft.rfftn(mesh_values, norm='backward', dim=dims)
        potential_hat = mesh_hat * G
        potential_mesh = torch.fft.irfftn(potential_hat, norm='forward', dim=dims) / volume

        return potential_mesh