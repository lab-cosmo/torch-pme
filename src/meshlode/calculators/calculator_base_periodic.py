from typing import List, Optional, Union

import torch

from .calculator_base import CalculatorBase


class CalculatorBasePeriodic(CalculatorBase):
    """
    Base calculator for periodic implementations
    """

    name = "CalculatorBasePeriodic"

    # Note that the base class also has this function, but with the parameter "cell"
    # only as an option. For periodic implementations, "cell" is a strictly required
    # parameter, which is why this function is implemented again.
    # This function is kept to keep MeshLODE compatible with the broader pytorch
    # infrastructure, which require a "forward" function. We name this function
    # "compute" instead, for compatibility with other COSMO software.
    def forward(
        self,
        types: Union[List[torch.Tensor], torch.Tensor],
        positions: Union[List[torch.Tensor], torch.Tensor],
        cell: Union[List[torch.Tensor], torch.Tensor],
        charges: Optional[Union[List[torch.Tensor], torch.Tensor]] = None,
    ) -> Union[torch.Tensor, List[torch.Tensor]]:
        """forward just calls :py:meth:`CalculatorModule.compute`"""
        return self.compute(
            types=types, positions=positions, cell=cell, charges=charges
        )

    def compute(
        self,
        types: Union[List[torch.Tensor], torch.Tensor],
        positions: Union[List[torch.Tensor], torch.Tensor],
        cell: Union[List[torch.Tensor], torch.Tensor],
        charges: Optional[Union[List[torch.Tensor], torch.Tensor]] = None,
        neighbor_indices: Union[List[torch.Tensor], torch.Tensor] = None,
        neighbor_shifts: Union[List[torch.Tensor], torch.Tensor] = None,
    ) -> Union[torch.Tensor, List[torch.Tensor]]:
        """Compute potential for all provided "systems" stacked inside list.

        The computation is performed on the same ``device`` as ``systems`` is stored on.
        The ``dtype`` of the output tensors will be the same as the input.

        :param types: single or list of 1D tensor of integer representing the
            particles identity. For atoms, this is typically their atomic numbers.
        :param positions: single or 2D tensor of shape (len(types), 3) containing the
            Cartesian positions of all particles in the system.
        :param cell: single or 2D tensor of shape (3, 3), describing the bounding
            box/unit cell of the system. Each row should be one of the bounding box
            vector; and columns should contain the x, y, and z components of these
            vectors (i.e. the cell should be given in row-major order).
        :param charges: Optional single or list of 2D tensor of shape (len(types), n),
        :param neighbor_indices: Optional single or list of 2D tensors of shape (2, n),
            where n is the number of atoms. The 2 rows correspond to the indices of
            the two atoms which are considered neighbors (e.g. within a cutoff distance)
        :param neighbor_shifts: Optional single or list of 2D tensors of shape (3, n),
            where n is the number of atoms. The 3 rows correspond to the shift indices
            for periodic images.

        :return: List of torch Tensors containing the potentials for all frames and all
            atoms. Each tensor in the list is of shape (n_atoms, n_types), where
            n_types is the number of types in all systems combined. If the input was
            a single system only a single torch tensor with the potentials is returned.

            IMPORTANT: If multiple types are present, the different "types-channels"
            are ordered according to atomic number. For example, if a structure contains
            a water molecule with atoms 0, 1, 2 being of types O, H, H, then for this
            system, the feature tensor will be of shape (3, 2) = (``n_atoms``,
            ``n_types``), where ``features[0, 0]`` is the potential at the position of
            the Oxygen atom (atom 0, first index) generated by the HYDROGEN(!) atoms,
            while ``features[0,1]`` is the potential at the position of the Oxygen atom
            generated by the Oxygen atom(s).
        """
        # make sure compute function works if only a single tensor are provided as input
        if not isinstance(types, list):
            types = [types]
        if not isinstance(positions, list):
            positions = [positions]
        if not isinstance(cell, list):
            cell = [cell]
        if (neighbor_indices is not None) and not isinstance(neighbor_indices, list):
            neighbor_indices = [neighbor_indices]
        if (neighbor_shifts is not None) and not isinstance(neighbor_shifts, list):
            neighbor_shifts = [neighbor_shifts]

        # Check that all inputs are consistent
        for types_single, positions_single, cell_single in zip(types, positions, cell):
            if len(types_single.shape) != 1:
                raise ValueError(
                    "each `types` must be a 1 dimensional tensor, got at least "
                    f"one tensor with {len(types_single.shape)} dimensions"
                )

            if positions_single.shape != (len(types_single), 3):
                raise ValueError(
                    "each `positions` must be a (n_types x 3) tensor, got at least "
                    f"one tensor with shape {list(positions_single.shape)}"
                )

            if cell_single.shape != (3, 3):
                raise ValueError(
                    "each `cell` must be a (3 x 3) tensor, got at least "
                    f"one tensor with shape {list(cell_single.shape)}"
                )

            if cell_single.dtype != positions_single.dtype:
                raise ValueError(
                    "`cell` must be have the same dtype as `positions`, got "
                    f"{cell_single.dtype} and {positions_single.dtype}"
                )

            if (
                positions_single.device != types_single.device
                or cell_single.device != types_single.device
            ):
                raise ValueError(
                    "`types`, `positions`, and `cell` must be on the same device, got "
                    f"{types_single.device}, {positions_single.device} and "
                    f"{cell_single.device}."
                )

        requested_types = self._get_requested_types(types)

        # If charges are not provided, we assume that all types are treated separately
        if charges is None:
            charges = []
            for types_single, positions_single in zip(types, positions):
                # One-hot encoding of charge information
                charges_single = self._one_hot_charges(
                    types=types_single,
                    requested_types=requested_types,
                    dtype=positions_single.dtype,
                    device=positions_single.device,
                )
                charges.append(charges_single)

        # If charges are provided, we need to make sure that they are consistent with
        # the provided types
        else:
            if not isinstance(charges, list):
                charges = [charges]
            if len(charges) != len(types):
                raise ValueError(
                    "The number of `types` and `charges` tensors must be the same, "
                    f"got {len(types)} and {len(charges)}."
                )
            for charges_single, types_single in zip(charges, types):
                if charges_single.shape[0] != len(types_single):
                    raise ValueError(
                        "The first dimension of `charges` must be the same as the "
                        f"length of `types`, got {charges_single.shape[0]} and "
                        f"{len(types_single)}."
                    )
            if charges[0].dtype != positions[0].dtype:
                raise ValueError(
                    "`charges` must be have the same dtype as `positions`, got "
                    f"{charges[0].dtype} and {positions[0].dtype}."
                )
            if charges[0].device != positions[0].device:
                raise ValueError(
                    "`charges` must be on the same device as `positions`, got "
                    f"{charges[0].device} and {positions[0].device}."
                )
        # We don't require and test that all dtypes and devices are consistent if a list
        # of inputs. Each "frame" is processed independently.
        potentials = []

        if neighbor_indices is None or neighbor_shifts is None:
            for positions_single, cell_single, charges_single in zip(
                positions, cell, charges
            ):
                # Compute the potentials
                potentials.append(
                    self._compute_single_system(
                        positions=positions_single,
                        charges=charges_single,
                        cell=cell_single,
                    )
                )
        else:
            for (
                positions_single,
                cell_single,
                charges_single,
                neighbor_indices_single,
                neighbor_shifts_single,
            ) in zip(positions, cell, charges, neighbor_indices, neighbor_shifts):
                # Compute the potentials
                potentials.append(
                    self._compute_single_system(
                        positions=positions_single,
                        charges=charges_single,
                        cell=cell_single,
                        neighbor_indices=neighbor_indices_single,
                        neighbor_shifts=neighbor_shifts_single,
                    )
                )

        if len(types) == 1:
            return potentials[0]
        else:
            return potentials
