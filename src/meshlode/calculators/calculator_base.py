from meshlode.lib import InversePowerLawPotential
from typing import List, Optional, Union

import torch


@torch.jit.script
def _1d_tolist(x: torch.Tensor) -> List[int]:
    """Auxilary function to convert 1d torch tensor to list of integers."""
    result: List[int] = []
    for i in x:
        result.append(i.item())
    return result


@torch.jit.script
def _is_subset(subset_candidate: List[int], superset: List[int]) -> bool:
    """Checks whether all elements of `subset_candidate` are part of `superset`."""
    for element in subset_candidate:
        if element not in superset:
            return False
    return True


class CalculatorBase(torch.nn.Module):
    """
    Base calculator

    :param all_types: Optional global list of all atomic types that should be considered
        for the computation. This option might be useful when running the calculation on
        subset of a whole dataset and it required to keep the shape of the output
        consistent. If this is not set the possible atomic types will be determined when
        calling the :meth:`compute()`.
    """

    name = "CalculatorBase"

    def __init__(
        self,
        all_types: Optional[List[int]] = None,
        exponent: Optional[torch.Tensor] = torch.tensor(1., dtype=torch.float64),
    ):
        super().__init__()

        if all_types is None:
            self.all_types = None
        else:
            self.all_types = _1d_tolist(torch.unique(torch.tensor(all_types)))
        
        self.exponent = exponent
        self.potential = InversePowerLawPotential(exponent = exponent)

    # This function is kept to keep this library compatible with the broader pytorch
    # infrastructure, which require a "forward" function. We name this function
    # "compute" instead, for compatibility with other COSMO software.
    def forward(
        self,
        types: Union[List[torch.Tensor], torch.Tensor],
        positions: Union[List[torch.Tensor], torch.Tensor],
        charges: Optional[Union[List[torch.Tensor], torch.Tensor]] = None,
    ) -> Union[torch.Tensor, List[torch.Tensor]]:
        """forward just calls :py:meth:`CalculatorModule.compute`"""
        return self.compute(
            types=types, positions=positions, charges=charges
        )

    def compute(
        self,
        types: Union[List[torch.Tensor], torch.Tensor],
        positions: Union[List[torch.Tensor], torch.Tensor],
        charges: Optional[Union[List[torch.Tensor], torch.Tensor]] = None,
    ) -> Union[torch.Tensor, List[torch.Tensor]]:
        """Compute potential for all provided "systems" stacked inside list.

        The computation is performed on the same ``device`` as ``systems`` is stored on.
        The ``dtype`` of the output tensors will be the same as the input.

        :param types: single or list of 1D tensor of integer representing the
            particles identity. For atoms, this is typically their atomic numbers.
        :param positions: single or 2D tensor of shape (len(types), 3) containing the
            Cartesian positions of all particles in the system.
        :param charges: Optional single or list of 2D tensor of shape (len(types), n),

        :return: List of torch Tensors containing the potentials for all frames and all
            atoms. Each tensor in the list is of shape (n_atoms, n_types), where
            n_types is the number of types in all systems combined. If the input was
            a single system only a single torch tensor with the potentials is returned.

            IMPORTANT: If multiple types are present, the different "types-channels"
            are ordered according to atomic number. For example, if a structure contains
            a water molecule with atoms 0, 1, 2 being of types O, H, H, then for this
            system, the feature tensor will be of shape (3, 2) = (``n_atoms``,
            ``n_types``), where ``features[0, 0]`` is the potential at the position of
            the Oxygen atom (atom 0, first index) generated by the HYDROGEN(!) atoms,
            while ``features[0,1]`` is the potential at the position of the Oxygen atom
            generated by the Oxygen atom(s).
        """
        # make sure compute function works if only a single tensor are provided as input
        if not isinstance(types, list):
            types = [types]
        if not isinstance(positions, list):
            positions = [positions]

        # Check that all inputs are consistent
        # We don't require and test that all dtypes and devices are consistent for a
        # list of inputs. Each "frame" is processed independently.
        for types_single, positions_single in zip(types, positions):
            if len(types_single.shape) != 1:
                raise ValueError(
                    "each `types` must be a 1 dimensional tensor, got at least "
                    f"one tensor with {len(types_single.shape)} dimensions"
                )

            if positions_single.shape != (len(types_single), 3):
                raise ValueError(
                    "each `positions` must be a (n_types x 3) tensor, got at least "
                    f"one tensor with shape {list(positions_single.shape)}"
                )

            if positions_single.device != types_single.device:
                raise ValueError(
                    "`types` and `positions` must be on the same device, got "
                    f"{types_single.device}, {positions_single.device}"
                )

        requested_types = self._get_requested_types(types)

        # If charges are not provided, we assume that all types are treated separately
        if charges is None:
            charges = []
            for types_single, positions_single in zip(types, positions):
                # One-hot encoding of charge information
                charges_single = self._one_hot_charges(
                    types=types_single,
                    requested_types=requested_types,
                    dtype=positions_single.dtype,
                    device=positions_single.device,
                )
                charges.append(charges_single)

        # If charges are provided, we need to make sure that they are consistent with
        # the provided types
        else:
            if not isinstance(charges, list):
                charges = [charges]
            if len(charges) != len(types):
                raise ValueError(
                    "The number of `types` and `charges` tensors must be the same, "
                    f"got {len(types)} and {len(charges)}."
                )
            for charges_single, types_single in zip(charges, types):
                if charges_single.shape[0] != len(types_single):
                    raise ValueError(
                        "The first dimension of `charges` must be the same as the "
                        f"length of `types`, got {charges_single.shape[0]} and "
                        f"{len(types_single)}."
                    )
            if charges[0].dtype != positions[0].dtype:
                raise ValueError(
                    "`charges` must be have the same dtype as `positions`, got "
                    f"{charges[0].dtype} and {positions[0].dtype}."
                )
            if charges[0].device != positions[0].device:
                raise ValueError(
                    "`charges` must be on the same device as `positions`, got "
                    f"{charges[0].device} and {positions[0].device}."
                )

        potentials = []
        for positions_single, charges_single in zip(positions, charges):
            # Compute the potentials
            potentials.append(
                self._compute_single_system(
                    positions=positions_single, charges=charges_single
                )
            )

        if len(types) == 1:
            return potentials[0]
        else:
            return potentials

    def _get_requested_types(self, types: List[torch.Tensor]) -> List[int]:
        """Extract a list of all unique and present types from the list of types."""
        all_types = torch.hstack(types)
        types_requested = _1d_tolist(torch.unique(all_types))

        if self.all_types is not None:
            if not _is_subset(types_requested, self.all_types):
                raise ValueError(
                    f"Global list of types {self.all_types} does not contain all "
                    f"types for the provided systems {types_requested}."
                )
            return self.all_types
        else:
            return types_requested

    def _one_hot_charges(
        self,
        types: torch.Tensor,
        requested_types: List[int],
        dtype: Optional[torch.dtype] = None,
        device: Optional[torch.device] = None,
    ) -> torch.Tensor:
        n_types = len(requested_types)
        one_hot_charges = torch.zeros((len(types), n_types), dtype=dtype, device=device)

        for i_type, atomic_type in enumerate(requested_types):
            one_hot_charges[types == atomic_type, i_type] = 1.0

        return one_hot_charges

    def _compute_single_system(
        self,
        positions: torch.Tensor,
        charges: torch.Tensor,
        cell: Optional[torch.Tensor] = None,
    ) -> torch.Tensor:
        """
        Core of the calculator that actually implements the computation of the potential
        using various algorithms.

        :param positions: torch.tensor of shape (n_atoms, 3). Contains the Cartesian
            coordinates of the atoms. The implementation also works if the positions
            are not contained within the unit cell.
        :param charges: torch.tensor of shape `(n_atoms, n_channels)`. In the simplest
            case, this would be a tensor of shape (n_atoms, 1) where charges[i,0] is the
            charge of atom i. More generally, the potential for the same atom positions
            is computed for n_channels independent meshes, and one can specify the
            "charge" of each atom on each of the meshes independently. For standard LODE
            that treats all (atomic) types separately, one example could be: If n_atoms
            = 4 and the types are [Na, Cl, Cl, Na], one could set n_channels=2 and use
            the one-hot encoding charges = torch.tensor([[1,0],[0,1],[0,1],[1,0]]) for
            the charges. This would then separately compute the "Na" potential and "Cl"
            potential. Subtracting these from each other, one could recover the more
            standard electrostatic potential in which Na and Cl have charges of +1 and
            -1, respectively.
        :param cell: torch.tensor of shape `(3, 3)`. Describes the unit cell of the
            structure, where cell[i] is the i-th basis vector. While redundant in this
            particular implementation, the parameter is kept to keep the same inputs as
            the other calculators.

        :returns: torch.tensor of shape `(n_atoms, n_channels)` containing the potential
        at the position of each atom for the `n_channels` independent meshes separately.
        """

        return torch.zeros_like(charges)
